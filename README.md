# mysql-
MySQL common knowledge

//创建库
CREATE DATABASE IF NOT EXISTS table_name DEFAULT CHARSET utf8 COLLATE utf8_general_ci;

//创建表（表中必备三个字段 id createtime modifytime）
CREATE TABLE IF NOT EXISTS table_name (
  id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  gmt_create DATETIME,
  gmt_modified DATETIME,
  PRIMARY KEY (id)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

*********************************************
explain的使用
 explain命令是查看查询优化器如何决定执行查询的主要方法 \G 按列显示

mysql> explain select id from users where id = 1 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: users
   partitions: NULL
         type: const    type {range(最低  range 对索引进行范围检索) ref (普通索引) consts 单表中最多只有一个匹配行（主键或者唯一索引}}  
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)


 type {range(最低  range 对索引进行范围检索) ref (普通索引) consts 单表中最多只有一个匹配行（主键或者唯一索引}} 
 反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index级别比较range 还低，与全表扫描是小巫见大巫。 
rows(预估要查询的行) )
extra(using where, using index（全覆盖） 避免回表) 

def:索引包含（亦称覆盖）所有需要查询的字段的值
覆盖索引就是从索引中直接获取查询结果，要使用覆盖索引需要注意select查询列中包含在索引列中；
where条件包含索引列或者复合索引的前导列；查询结果的字段长度尽可能少。
**********************************************
经验法则：：考虑全局基数和选择性

count(distinct left(列名, 索引长度))/count(*) 
计算列的完整性

多列索引
最左前缀匹配

**********************************************

字段（用最小的精度来保证字段的可用性和范围）

尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED

VARCHAR的长度只分配真正需要的空间

使用枚举或整数代替字符串类型

尽量使用TIMESTAMP而非DATETIME，

单表不要有太多字段，建议在20以内

避免使用NULL字段，很难查询优化且占用额外索引空间

用整型来存IP


******************************************


索引
索引要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描

应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描

值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段

字符字段只建前缀索引

字符字段最好不要做主键

不用外键，由程序保证约束

尽量不用UNIQUE，由程序保证约束

使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引


****************************************************************


查询SQL
可通过开启慢查询日志来找出较慢的SQL

不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边

sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库

不用SELECT *

OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内

不用函数和触发器，在应用程序实现

exits 使用于外层远小于内层的查询（先看内层是否为TRUE，然后从外层依次查询，查询为外层的长度） 尽量不用in 、

避免%xxx式查询

少用JOIN（join不超过三个表）

使用同类型进行比较，比如用'123'和'123'比，123和123比

尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描

对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5

列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大

********************************************************


关系性数据库需要遵循ACID规则，具体内容如下：
原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性： 执行事务前后，数据保持一致；
隔离性： 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
持久性: 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。
为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：

READ_UNCOMMITTED（未授权读取）: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读

READ_COMMITTED（授权读取）: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

REPEATABLE_READ（可重复读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

SERIALIZABLE（串行）: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

详细内容可以参考： 可能是最漂亮的Spring事务管理详解

⑥锁机制与InnoDB锁算法
MyISAM和InnoDB存储引擎使用的锁：

MyISAM采用表级锁(table-level locking)。
InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
表级锁和行级锁对比：

表级锁： Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
行级锁： Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
详细内容可以参考： Mysql锁机制简单了解一下

InnoDB存储引擎的锁的算法有三种：

Record lock：单个行记录上的锁
Gap lock：间隙锁，锁定一个范围，不包括记录本身
Next-key lock：record+gap 锁定一个范围，包含记录本身
相关知识点：

innodb对于行的查询使用next-key lock
Next-locking keying为了解决Phantom Problem幻读问题
当查询的索引含有唯一属性时，将next-key lock降级为record key
Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1
***********************************************************


读写分离
也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离
********************************************************
表分区
分区的类型：

RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区

LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择

HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式

KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
**********************************************************
分区适合的场景

最适合的场景数据的时间序列性比较强，则可以按时间来分区
查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。
**********************************************************
大表拆分
水平拆分 ，不破坏表的字段结构，将1000万分为两个五百万的表
垂直拆分，将冷热数据分开，将BLOB TXT 大字段按照主键对应拆分
*********************************************************



*********************************************************

*********************************************************
内容参考:
1、阿里开发手册MySQL数据库
2、大表优化方案（转载）
https://segmentfault.com/a/1190000006158186
3、https://github.com/Snailclimb/JavaGuide/blob/master/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MySQL.md
